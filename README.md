# NJU2023秋编译原理Lab4

姓名：闻嘉迅  
学号：211220091  
首次编写日期：2024.1.10
### 1.功能实现

- 基础功能，根据中间代码生成目标代码(可能有问题)  

### 2.编译方法

编译工具版本：  
gcc version 11.4.0     
flex 2.6.4  
bison (GNU Bison) 3.8.2  

进入Code文件夹，在此目录下输入`make parser`命令进行编译，`./parser [filename] [outputfile]` 执行命令。  

### 3.文件结构

lex.l:词法分析器相关代码  
parser.y:语法分析器相关代码  
syntax_tree.h:语法树生成的相关函数声明  
syntax_tree.c:语法树生成的相关函数实现  
syntax_check_update.h:语法树的检查和更新的函数声明
syntax_check_update.c:语法树的检查和更新的函数实现  
hash.h:哈希表相关函数的声明
hash.c:哈希表相关函数的实现
stack.h:栈的声明
stack.c:栈的实现
ir.h:中间代码生产函数的声明
ir.c:中间代码生产函数的实现
main.c:主函数部分  

**lab4新增**  
reg.h:寄存器分配相关函数的声明  
reg.c:寄存器分配相关函数的实现  
obj.h:生成目标代码函数的声明  
obj.c:生成目标代码函数的实现  


### 4.具体实现

#### 寄存器的分配

这部分主要在reg.c中实现，主要函数功能如下：  

**regAssign函数**  
该函数负责为特定变量分配寄存器，负责的寄存器有：REG_zero、REG_v1、REG_t0-t7、REG_s0-s7。  
首先判断传入的变量名，若为特殊变量(如temp_1对应常量0,temp_0对应输入缓冲区)分配特殊寄存器(REG_zero和REG_v1)。  
若为一般变量，则查询变量表，若addr项为0则表示该项未被分配，则在栈区分配空间并在addr项记录相应的地址。随后检查regidx项并查询寄存器占用列表regmap，若检查结果为该变量已被分配了一个寄存器，则将其寄存器标号返回，否则表示该变量未在寄存器中将分配一个寄存器。  
若regmap显示还有未占用的寄存器，则将其分配，否则调用`selectMark`函数选择一个占用寄存器的变量进行替换。进行替换后从地址处加载数据以保证数据同步，并将use项设置为1以表示该寄存器已被占用(该标记可被clearuse函数清除以解除占用)。最后返回分配到的寄存器标号。    

**selectMark函数**  
该函数接收一个变量表标号表示需要分配寄存器的变量，返回一个需要被替换掉的变量表标号。  
若该变量的regidx标号为-1(即第一次分配寄存器)则随机选取一个未被占用的寄存器所对应的变量表标号。  
否则，根据该变量的regidx标号选择对应的寄存器所对应的变量表标号(若该寄存器已占用则重新选取)。如此可保证在执行循环时可获得正确的寄存器。  

**updateVal函数**  
该函数接收一个变量名并将它的值更新。  
首先更新该变量的时间戳，并调用`saveValue`函数保存新值。
在`saveValue`函数中使用`sw`命令储存寄存器的值，并将use标志清除以接触寄存器占用。  

此外，还有用于初始化寄存器表、重置寄存器、分配数组空间和获取函数实参的相关函数。  

#### 指令选择

这部分主要在obj.c中实现，主要函数功能如下：  

**getObjHeader函数**  
该函数构造了目标文件头。  

**getReadFunc函数和getWriteFunc函数**  
这两个函数实现了read()和write()函数。  

**callFunc函数**  
这个函数接收一个函数名，并生成函数调用相关操作的代码。  

**objtrans函数**  
这个函数接收一个中间代码文件指针，并将这些中间代码翻译成目标代码。  
首先依次调用`getObjHeader getReadFunc getWriteFunc`函数，生成文件头和输入输出函数。  
再依次读取每行中间代码，依照代码类型调用相应的宏生成指令，并为变量分配相应的寄存器，最终输出到目标代码文件中。  